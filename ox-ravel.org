
#+TITLE:     ox-ravel.org
#+AUTHOR:    Charles Berry
#+EMAIL:     ccberry@ucsd.edu
#+DATE:      2012-10-04
#+COMMENT: latest revision 2014-08-24
#+DESCRIPTION: Sweave/knit/brew document maker for orgmode
#+KEYWORDS:
#+LANGUAGE:  en
#+OPTIONS:   H:3 num:t toc:nil \n:nil @:t ::t |:t ^:t -:t f:t *:t <:t
#+OPTIONS:   TeX:t LaTeX:t skip:nil d:nil todo:t pri:nil tags:not-in-toc
#+INFOJS_OPT: view:nil toc:nil ltoc:t mouse:underline buttons:0 path:http://orgmode.org/org-info.js
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport
#+LINK_UP:
#+LINK_HOME:
#+XSLT:
#+DRAWERS: DEVNOTES TODOWHAT
#+PROPERTY: header-args :tangle ox-ravel.el :comments org


* Background
  :PROPERTIES:
  :eval:     never
  :END:
** browsing this file

~ox-ravel.org~ is an orgmode file.

If you have downloaded a copy of ~ox-ravel.org~, it is best to view it
using [[orgmode][orgmode]], which is a part of recent distributions of GNU
Emacs. In other words, it should suffice to open the file using emacs.

** quickstart guide

If you already know ~orgmode~ and either ~knitr~, ~Sweave~, or
~brew~, you can just

- skip to [[lisp setup]["lisp setup"]] to install ravel
- browse one or more [[examples][examples]]
  - you can type =C-c C-e r <letter>= (where =<letter>= is one of the
    listed menu items) in those files to try out the exporter
- review the section [[what ravel does]["what ravel does"]]

** orgmode

[[http://orgmode.org/index.html][Orgmode]] is /for keeping notes, maintaining TODO lists, doing project planning, and authoring with a fast and effective plain-text system./ The same org document can be used to create LaTeX, HTML, plain ASCII, and various other formats upon export.

[[http://orgmode.org/worg/org-contrib/babel/index.html][Babel]] is /Org-mode's ability to/ /execute source code/ /within Org-mode documents/. It is powerful and flexible and a useful tool for generating reproducible research reports as outlined in [[http://www.jstatsoft.org/v46/i03][the report :]] Eric Schulte, Dan Davison, Thomas Dye, and Carsten Dominik. A Multi-Language Computing Environment for Literate Programming and Reproducible Research. Journal of Statistical Software. 46(3) Jan 2012. Source code blocks can be editted in place or in a language major-mode edit buffer containing the body of the code block. And for R blocks, ~ESS~ is fully functional.

** R document/report Generators

There are many markup and report and document generating packages and
functions for R. A useful overview of them is at [[http://cran.r-project.org/web/views/ReproducibleResearch.html][CRAN Task View for
Reproducible Research]]

Several to which this software is aimed are

   - Sweave :: This R function is the basic workhorse for many report
               and document generating functions. It uses (by default)
               a noweb type syntax to separate code chunks from LaTeX
               markup and can be run to /weave/ reports or /tangle/
               executable code.. It described in
               detail at
     - [[http://www.statistik.uni-muenchen.de/~leisch/Sweave/][the Sweave homepage]] and in
     - Friedrich Leisch. Sweave: Dynamic generation of statistical
       reports using literate data analysis. In Wolfgang Härdle and
       Bernd Rönz, editors, Compstat 2002 - Proceedings in
       Computational Statistics, pages 575-580. Physica Verlag,
       Heidelberg, 2002. ISBN 3-7908-1517-9.


   - brew :: This R package uses a simple PHP-like syntax to markup
               documents mixing text and code which are then through
               the ~brew()~ function. It is described in the help documents for the package:
       - Jeffrey Horner (2011). brew: Templating Framework for Report
         Generation. R package version 1.0-6.
         http://CRAN.R-project.org/package=brew

   - knitr :: This R package is an attempt to combine and unify the
                 best features of many report generating/markup
                 package and functions in R. It is described in

	 - Yihui Xie (2012). knitr: A general-purpose package for
           dynamic report generation in R. R package version 0.6.3.
           http://CRAN.R-project.org/package=knitr and

	 - [[http://yihui.name/knitr/][The knitr home page]]

** Putting orgmode and Sweave together

Each approach (orgmode as report generator vs Sweave-like report
generators) has its own strengths and weaknesses.

After years of using Sweave for report creation, I tried to use
orgmode to construct a research report from a moderate sized database
using some simulations and lengthy statistical resampling routines. I
got through the first draft of the report and a 25-page supplement
using orgmode/Babel.

I really liked the ease with which I could organize some things in the
process - like notes, emails from collaborators, TODO lists, and code
snippets and intermediate results that might not show up in the final
report or supplement or whose location was uncertain. Being able to
run code snippets and have the results saved in the master document
and be able to toggle to view LaTeX snippets and graphics rendered in
place was very slick.

However, there were some things I really missed that were helpful in
the Sweave style of work. There are /dependency aware/ caching systems
in R that are simple and powerful; you can change a line of code and
rerun the document and all the pieces that need to be recomputed are
rebuilt and recached. And it all happens in a flash if all you needed
to do was change a format in table or anything that doesn't require a
large object to be rebuilt. And when a large object is rebuilt, all
its dependencies get updated, too. I ended up building a collection of
intermediate R objects to make the build/revision process execute in
finite time, but maintaining them and rebuilding them as needed was a
nuisance. Some componenents of the project required only a subset of
objects and the R packages that access them and I ended up having to
sprinkle links to the code to ~load~ or ~require~ throughout the
orgmode file. In the end, the orgmode files that served as the master
and the supplement were more than 7500 lines long and had more than
130 R source code blocks. And to be honest, there were some
stand-alone R scripts and a separate org file that had over 100 source
code blocks in to to manange the CPU intensive computations. It ended
up being pretty ungainly.

Also, there are some nice formatting tools available and more coming
into use. And many of them are hard (or maybe impossible) to use when
Babel is doing the final report generation. I did use =brew= under
Babel, but it was truly an awkward process.

I saw terrific possibilities presented by new (as of July 2012) R
packages in development like [[http://yihui.name/knitr/][=knitr=]] and [[https://github.com/daroczig/pander][=pander=]]. I switched to
=knitr= for several recent projects, but I wanted to retain the
features of orgmode+Babel for my workflow. The Org export engine (see
the Org manual [[http://orgmode.org/org.html#Exporting][Exporting]] section or [[http://orgmode.org/worg/dev/org-export-reference.html][Org Export Reference
Documentation]]) made it possible to have a workstyle in which an
orgmode master document contains a /subtree/ with text and code blocks
that when exported becomes a knitr, Sweave or brew style document that
when run produces LaTeX, HTML, and/or some other markup language. By
including caching options in those documents the development process
becomes easy to organize, restarting work after a break is just a
matter of rerunning the document to load the cached objects and
libraries, then switching to the orgmode master to try out some new
code, reorganize the presentation, and so on.


* lisp setup
  :PROPERTIES:
  :eval:     never
  :CUSTOM_ID: lispset
  :END:

** extract ox-ravel.el and load it

   These two lines should do the trick:

#+BEGIN_SRC emacs-lisp :tangle no
(org-babel-tangle)
(load-file "ox-ravel.el")
#+END_SRC

Now you can use ravel.

** Install ox-ravel

For everyday use, move =ox-ravel.el= into your load path,
e.g. =~/.emacs.d/= or =~/elisp/= and add ~(require 'ox-ravel)~ to your
startup.

* examples

Some =*.org= files in this directory show how the available backends
can be used. Check out

 - =demos.org= :: simple examples.
 - =test-cases.org= :: comparison of plain latex and latex with chunks
      rendered in the =rnw= and =brew= styles.
 - =example-1-Rnw.org= :: an org version =example-1.Rnw= from the R =utils= package.
 - =knitr-minimal-rhtml.org= :: an org version of =003-minimal.Rhtml=
 from =github.com/yihui/knitr-examples/=
* ravel
  :PROPERTIES:
  :eval:     never
  :END:

*************** 

Things to think about:
- load, require, autoload, provide
- Commentary and Code as per checkDoc
- dexy does integration of documents, see [[http://www.dexy.it/faq/#how-is-dexy-different-to-sweave][Dexy FAQ]], maybe later ...

- melpa might be a good way to distribute: [[http://melpa.milkbox.net/][MELPA homepage]]

- DO flet: use org-flet instead - [2012-08-17 Fri] HUH? org-flet is
  gone!!! Back to plain old flet. Push this to github along with other
  new stuff.

- DONE: I have set up to combine :ravel and #+ATTR_RAVEL: then

- Save the header info as #+ATTR_R-HEADERS: then parse the header info in
  the src block function and
  possibly refer to its values in setting up the chunk.

- exporting brew style to *.org might be an awesome capability. Here is how to do it:
  1. write the usual code including `:ravel <%[=] ... [{}][-]%>' arguments
     - install a hook for org-export-before-parsing-hook that will
     - (copy and) save the temp buffer
     - run R and call brew( <the saved copy> )
     - ad-deactivate as needed
     - (stop "all done") or
     - copy the saved buffer back to working buffer and continue. Under
       this option, one can later use the saved buffer to export to
       other formats
     - then just export with any backend that supports brew
  2. put brew delimiters in an *.org file
     - run brew on that file and write another file
     - export that file as usual, possibly letting babel work as usual


Mostly DONE:
- so here is what I am figuring out:
  - DONE need to advise org-babel-exp-do-export
    - to strip results of R blocks
    - to pre-format R src-blocks and inline src blocks
    - to pre-format and possibly run non-R source blocks according to
      the original parent (e.g. latex)
  - DONE advise org-export-as to
    - add hook for pre-parsed buffer
    - ad-activate org-babel-exp-do-export
    - ad-do-it
    - remove hook for pre-parsed buffer
    - ad-deactivate
    so that other back-ends are not tripped up
  - DONE define a universal src-block function
  - DONE define a universal inline-src-block function
  - define a back-end specific src-block format [DONE for latex-brew
    and latex-noweb]
  - define a back-end specific inline-src-block format [LIKEWISE]
  - DONE for the non-R src block function, use the ancestral version
  - DONE for the non-R inline src block function, use ancestor
  - NB ( assoc 'src-block (reverse org-rnw-translate-alist)) will
    find the ancestor!!!! - might need to revise for multiply derived
    backends like ox-md.
  - NB org-export-before-parsing-hook is handy - it can remove delimiters
    I insert to subvert babel's machinations.
  - need to add a native knitr backend
  - DONE src_R{} idiom is tricky. org-babel-inline-src-block-regexp
    needs whitespace between the [args] if any in the src_R call. So,
    I add that in the flet'ed version of org-babel-execute:R.

    
*************** END

** The elisp header for ox-ravel.el

 #+BEGIN_SRC emacs-lisp :tangle ox-ravel.el :comments no
   ;;; ox-ravel.el --- Sweave/knit/brew document maker for orgmode
   ;; Copyright (C) 2012,2014  Charles C. Berry

   ;; This program is free software: you can redistribute it and/or modify
   ;; it under the terms of the GNU General Public License as published by
   ;; the Free Software Foundation, either version 3 of the License, or
   ;; (at your option) any later version.

   ;; This program is distributed in the hope that it will be useful,
   ;; but WITHOUT ANY WARRANTY; without even the implied warranty of
   ;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   ;; GNU General Public License for more details.

   ;; You should have received a copy of the GNU General Public License
   ;; along with this program.  If not, see <http://www.gnu.org/licenses/>.

   ;;; Commentary:
   ;;              See ox-ravel.org for details.
   ;;
   ;;; Code:
   ;;
 #+END_SRC

 Prerequisites

 #+BEGIN_SRC emacs-lisp :tangle ox-ravel.el
   (require 'ox)
 #+end_src

 #+END_SRC
 :END:


** using and extending ravel

*** what ravel does

~ravel~ allows exporting ~*.org~ files or subtrees in them to several
reproducible research formats: ~brew~, ~Sweave~, and several ~knitr~
formats (brew, Rnw, Rmd, and Rhtml).

With ~ox-ravel-el~ loaded and the point in a =*.org= buffer,

: C-c C-e

or

: M-x org-export-dispatch RET

will pop up a menu of choices. Optionally, type ~C-s~ to select the
subtree containing point. Then type =r= to select the =Ravel= menu.
The keys on that menu allow export to one of the formats supported by
~ravel~.

~ravel~ exports the file or subtree in a suitable format
(currently LaTeX, HTML, or Markdown), but with differences from the
usual export mechanism in which the source code (aka src blocks) are
evaluated by orgmode's Babel engine and (optionally) code and/or
results are passed to the exporter.

Before the document is parsed, Babel is run. However, R src blocks are
not evaluated in the usual way. Instead they are processed as if they
were ~ravel~ language src blocks. The ~ravel~ language takes a block
of code and marks it up to define chunks according to the convention
of Sweave, knitr, or some other report generator.  Src blocks with the
~:noweb yes~ header argument are expanded (by inserting the code from
the blocks in the noweb references) before being marked up.  R src
blocks that have the ~:exports none~ header argument are ignored. Src
blocks in other languages are evaluated and exported as usual.

Thus, a document can define many R src blocks and select a few to
export by constructing a subtree with src blocks that include noweb
references in them and for which ~:noweb yes~ is specified. Then, just
that subtree can be exported.

An R header argument named ~:ravel~ and ~:attr_ravel~ properties are
passed to the exporter for use as options in the ultimate code
chunks. So, ~knitr~ chunk options such as 'results="as.is"' would be
given as ~ravel~ arguments. The way these are handled depends on the
backend; for ~knitr~ they are placed as chunk options and for ~brew~
they are used to construct variants of the '<% ... %>' code
delimiters.

Once Babel is finished, the exporter takes over. Typically, an export
backend is dierived from an existing backend like ~latex~, and
merely adds transcoders for handling the marked up src blocks or
inline src, and menu selections.

*** existing backends

Currently, backends are avaiable for

- ~ravel-latex~ :: LaTeX Sweave, knitr, or brew documents
- ~ravel-beamer~ :: LaTeX Sweave and knitr beamer documents
- ~ravel-markdown-~ :: Markdown knitr documents
  - ~ravel-html~ :: HTML knitr/Rhtml documents


A look at the ~*.org~ files in [[examples][the examples section]] should provide a
quickstart.  A look (below) at the definitions of the style functions
for these backends should guide further devlopment.

*** explicit specification of arguments in exported chunks

Arguments that need to be passed to exported code chunks can be placed
after a ~:ravel~ key in a ~#+begin_src R~ line. Or they can be given
in ~#+ATTR_RAVEL:~ lines immediately before the src block.

Some care is needed. Arguments for some backends may conflict with
other backends. In future development, it might help to prefix
arguments with the name of their backend.

*** TODO using Babel header arguments in exported code chunks

Babel headers as a string parseable by
`org-babel-parse-header-arguments' are made available to the
~org-ravel-blockify~ function in the ~non-ravelargs~ argument. This
would allow translation of some org-babel R header arguments
to exported chunk headers.  `org-ravel-style-list' defines the
allowable styles for chunks and adding to that list allows for special
handling of Babel header args.  The src block and inline processing
functions of a style would need to inspect the alist of
~r-headers-attr~ and find those that can be (re-)rendered and add the
necessary arguments to the output string in the header position along
with the arguments provided by the ~ravel~ argument.

*** new backends

A new =ravel= backend can be created with the function
`org-ravel-define-exporter'. See its docstring for more details.The
~ravel-markdown~ exporter was defined using the code in the next src
block.


#+BEGIN_SRC emacs-lisp :exports code :tangle no
  (org-ravel-define-exporter
   'ravel-markdown
   'md ?m "Ravel-markdown" "md" nil t )
#+END_SRC


It is fairly easy to add more backends. There are these
ingredients needed:

1. chunk style function - usually chosen from `org-ravel-style-alist'
2. inline style function - ditto
3. a call to setup up the derived backend
4. (optionally) a function to work with the ~org-export-dispatch~ menu

The examples below should serve to show what is needed to create
different chunk and inline styles.

* TODO Babel

** variables
*** defconst-org-babel-header-args:ravel
#+NAME: defconst-org-babel-header-args:ravel
#+BEGIN_SRC emacs-lisp
  (defconst org-babel-header-args:ravel
    '(
      (ravel               . (:any))
      (ravel-style         . :any)
      (engine              . :any)
      (exports             . :any)
      (results             . ((file list vector table scalar verbatim)
                              (raw org html latex code pp wrap)
                              (replace silent append prepend)
                              (output value graphics))))
    "Ravel-specific header arguments.")
#+END_SRC
*** defvar-org-ravel-style

#+NAME: defvar-org-ravel-style
#+BEGIN_SRC emacs-lisp
  (defvar org-ravel-style nil
    "The default style to use for constructing chunks.
  Can be buffer-local, and is usually set by the export dispatcher.")

  (make-variable-buffer-local 'org-ravel-style)
#+END_SRC
*** defvar-org-ravel-run

#+NAME: defvar-org-ravel-run
#+BEGIN_SRC emacs-lisp
  (defvar-local org-ravel-run nil
    "If ravel is to be run on src blocks, this will be a list like

         '(\"R\") or '(\"R\" \"python\" \"awk\")

  and usually set (by the export dispatcher) to `org-ravel-engines'.

  Set this as buffer/file local for demos or debugging.")

#+END_SRC

*** defcustom-org-ravel-engines


#+NAME: defcustom-org-ravel-engines
#+BEGIN_SRC emacs-lisp

  (defcustom org-ravel-engines '(("R"))
    "Use these engines in forming ravel chunks.

  Typically, `org-ravel-run' will default to these.  It can be
  buffer-local.  These engines are recognized by `knitr':

        `R' `python' `awk' `ruby' `haskell' `bash' `perl' `dot'
         `tikz' `sas' `coffeescript' and `polyglot'.

  Each alist CONS cell has the language (as a string) for the CAR and
  any cdr is cons-ed to the ravel attributes.

  Buffer local values are allowed."
 
   :group 'org-export-ravel

   :type '(set :greedy t
               (const :tag "   R" ("R") )
               (const :tag "   Python" ("python" . "engine='python'"))
               (const :tag "   AWK" ("awk" . "engine='awk'"))
               (const :tag "   Ruby" ("ruby" . "engine='ruby'"))
               (const :tag "   Haskell" ("haskell" . "engine='haskell'"))
               (const :tag "   bash" ("bash" . "engine='bash'"))
               (const :tag "   perl" ("perl" . "engine='perl'"))
               (const :tag "   dot" ("dot" . "engine='dot'"))
               (const :tag "   TikZ" ("tikz" . "engine='tikz'"))
               (const :tag "   SAS" ("sas" . "engine='sas'"))
               (const :tag "   CoffeeScript"
                      ("coffeescript" . "engine='coffeescript'"))
               (const :tag "   Polyglot" ("polyglot" . "engine='polyglot'"))
               (string  :tag "   Other")))


  (make-variable-buffer-local 'org-ravel-engines)
#+END_SRC

*** TODO setq-org-ravel-style-alist
:TODOWHAT:
use `defcustom' here
:END:

#+NAME: setq-org-ravel-style-alist
#+BEGIN_SRC emacs-lisp
  (setq org-ravel-style-alist
       '((rnw . (org-ravel-block-rnw org-ravel-inline-rnw ".Rnw"))
        (brew . (org-ravel-block-brew org-ravel-inline-brew ".Rbrew"))
        (tex  . (org-ravel-block-tex org-ravel-inline-tex ".Rtex"))
        (html . (org-ravel-block-html org-ravel-inline-html ".Rhtml"))
        (md   . (org-ravel-block-md org-ravel-inline-md ".Rmd"))
        (braces   . (org-ravel-block-braces org-ravel-inline-braces ".Rtmpl"))
        (rst  . (org-ravel-block-rst org-ravel-inline-rst ".Rrst"))))
#+END_SRC


#+NAME: defcustom-org-ravel-style-alist
#+BEGIN_SRC emacs-lisp :tangle no
    (defgroup org-export-ravel nil
      "Options for exporting Org mode files via Ravel."
      :tag "Org Export Ravel"
      :group 'org-export)

  (defcustom org-ravel-style-alist
    '((rnw . (org-ravel-block-rnw org-ravel-inline-rnw ".Rnw"))
      (brew . (org-ravel-block-brew org-ravel-inline-brew ".Rbrew"))
      (tex  . (org-ravel-block-tex org-ravel-inline-tex ".Rtex"))
      (html . (org-ravel-block-html org-ravel-inline-html ".Rhtml"))
      (md   . (org-ravel-block-md org-ravel-inline-md ".Rmd"))
      (rst  . (org-ravel-block-rst org-ravel-inline-rst ".Rrst")))
    "The Chunk Style Alist to use in formatting Ravel output.

  The key of each element is matched by the `:ravel-style' property
  of a document, if specified, or by the default `:ravel-style' of
  the exporter selected.

  The value of each pair is a list of three elements:
    - the function that formats src blocks
    - the function that formats inline src blocks
    - a string giving the file extension. "
    :group 'org-export-ravel
    :type '(alist
            :key-type (symbol :tag "Ravel Style")
            :value--type (list :tag "Chunk Defn"
                               (function :tag "block coder")
                               (function :tag "inline coder")
                               (string :tag "File extension"))))

#+END_SRC

** TODO functions, macros,  and advice
**************** 
   TODO
Or maybe not...

After http://thread.gmane.org/gmane.emacs.orgmode/87533/focus=87845
patches are accepted, convert the code below to use :exports code, so
`org-babel-exp-do-export' will use `org-babel-exp-code' instead of
running `org-babel-exp-results'. Simplifies a lot.
- no need to change :lang ravel
- no need to set :results raw
- cleaning old results is automagic
Need to do:
- advice org-babel-exp-code to
  - call org-babel-expand-src-block to do :var assignment
  - noweb expansion just works
  - apply the chunk style functions as per --snippetize/blockify
  - let-bind org-babel-exp-code-template if (member lang engines)
  - let-bind org-babel-exp-inline-code-template if (member lang engines)

*************** END


*** defadvice-org-babel-parse-inline-src-block-match

#+NAME: defadvice-org-babel-parse-inline-src-block-match
#+BEGIN_SRC emacs-lisp
  (defadvice org-babel-parse-inline-src-block-match
    (after org-ravel-change-inline-lang activate)
    "Turn lang to ravel and add `:engine' header  maybe."
    (if
        (org-ravel-engine-to-ravel ad-return-value)
        (org-ravel-set-raw-results ad-return-value)))
#+END_SRC

#+RESULTS: defadvice-org-babel-parse-inline-src-block-match
: org-babel-parse-inline-src-block-match

*** defadvice-org-babel-parse-src-block-match
#+NAME: defadvice-org-babel-parse-src-block-match
#+BEGIN_SRC emacs-lisp
  (defadvice org-babel-parse-src-block-match
    (after org-ravel-change-sb-lang activate)
    "Turn lang to ravel, add `:engine' header, and :wrap ravel maybe."
    (if (org-ravel-engine-to-ravel ad-return-value)
        (org-ravel-rewrap ad-return-value)))
#+END_SRC

#+RESULTS: defadvice-org-babel-parse-src-block-match
: org-babel-parse-src-block-match

*** defalias-org-babel-expand-body

#+NAME: defalias-org-babel-expand-body:ravel
#+BEGIN_SRC emacs-lisp
  (defalias 'org-babel-expand-body:ravel 'org-babel-expand-body:R
    "Do what R does here.")
#+END_SRC
*** defun-org-ravel-engine-to-ravel

#+NAME: defun-org-ravel-engine-to-ravel
#+BEGIN_SRC emacs-lisp
  (defun org-ravel-engine-to-ravel (retval)
    "Maybe change lang to `ravel' in RETVAL.

  If so save lang as `:engine' header,and force `:exports results'.

  See docstrings for `org-ravel-run' and `org-ravel-engines' to see
  how to make ravel recognize which lang-s should be handled as
  engines."
    (when (and (boundp 'org-ravel-run)
               org-ravel-run
               (assoc (nth 0 retval) org-ravel-run))
      (let ((nth-2-retval (nth 2 retval)))
        (add-to-list 'nth-2-retval
                     `(:engine . ,(assoc (nth 0 retval) org-ravel-engines)))
        (setf (nth 0 retval) "ravel")
        (unless (equal (cdr (assoc :exports nth-2-retval)) "none")
          (setf (cdr (assoc :exports nth-2-retval)) "results"))
        (setf (nth 2 retval) nth-2-retval))))


#+END_SRC




*** defun-org-ravel-rewrap

Wrap the results of `org-babel-execute:ravel' in a
:#+BEGIN_RAVEL ... #+END_RAVEL block.

#+NAME: defun-org-ravel-rewrap
#+BEGIN_SRC emacs-lisp
  (defun org-ravel-rewrap (retval)
    ":wrap with `ravel' maybe.
  Argument RETVAL is the parsed src block."
    (if (assoc :wrap (nth 2 retval))
        (setf (cdr (assoc :wrap (nth 2 retval))) "ravel")
      (setf (nth 2 retval)  (append (nth 2 retval)
                                    '((:wrap . "ravel"))))))

#+END_SRC
*** defun-org-ravel-set-raw-results

The inline results are in ~@@ravel: ... @@~ snippets. Do not allow
further formatting.

#+NAME: defun-org-ravel-set-raw-results
#+BEGIN_SRC emacs-lisp
  (defun org-ravel-set-raw-results (retval)
    "Set (:results raw replace).
  Argument RETVAL is the parsed src block."
    (if (assoc :results (nth 2 retval))
        (setf (cdr (assoc :results (nth 2 retval))) "raw replace")
      (setf (nth 2 retval)
            (append (nth 2 retval)
                    '((:results . "raw replace"))))))

#+END_SRC
*** defvar-org-ravel-no-confirm-for-ravel

Confirmation of ravel `execution' is a nuisance --- and no code is
actually run --- so disable confirmations for `ravel' src blocks.
This can be overridden by `(setq org-ravel-no-confirm-for-ravel t)' if
ever needed.


Maybe need to add check if (functionp org-confirm-babel-evaluate) is
nil in which case, I do not reset it.

#+NAME: defvar-org-ravel-no-confirm-for-ravel
#+BEGIN_SRC emacs-lisp
  (defvar org-ravel-no-confirm-for-ravel
    (lambda (language body)
      (if (string= language "ravel") nil t))
    "Do not confirm if LANGUAGE is `ravel'.")

  (defun org-ravel-reset-confirm (value)
    "Revert `org-confirm-babel-evaluate' as buffer local VALUE."
    (when org-confirm-babel-evaluate
      (setf org-confirm-babel-evaluate
            value)))

#+END_SRC
*** TODO defun-org-babel-execute:ravel
*************** 
    TODO
engine needs to go somewhere.

- Maybe best to pass it on to the chunk styling functions. That way,
  brew chunks can ignore the engine spec in sorting out how to handle
  the ravel spec.

- or cons it to ravel-attr, which brew can ignore


*************** END


`org-babel-execute:ravel' calls formatting functions for the code. No
actual code is run. Also need to add some kind of alias for edit modes
if Rcpp is to be supported. Like `(defalias 'Rcpp-mode 'c++-mode)'

#+NAME: defun-org-babel-execute:ravel
#+BEGIN_SRC emacs-lisp
  (defun org-babel-execute:ravel (body params)
    "Format BODY as ravel according to PARAMS."
     (save-excursion
       (if (string= "none" (cdr (assoc :exports params)))
           ""
         (let*
             ((oec (org-element-context))
              (ravel-attr (org-element-property :attr_ravel oec))
              (type (org-element-type oec))
              ;; Need (org-babel-params-from-properties "ravel") here as
              ;; parsing was done on "R" or other language.
              (headers  (apply #'org-babel-merge-params
                               (append
                                (org-babel-params-from-properties "ravel")
                                (list params))))
              (ravelarg (cdr (assoc :ravel headers)))
              (engine (cddr (assoc :engine headers)))
              (ravelstyle (cdr (assoc :ravel-style headers)))
              (label (org-element-property :name oec))
              (non-ravelargs (assq-delete-all :ravel headers))
              (chunk-style
               (org-ravel-get-style ravelstyle))
	      (body (org-remove-indentation body))
              (full-body
               (org-babel-expand-body:ravel body params)))
           (when engine
             (setq ravel-attr
                   (cons engine
                         ravel-attr)))
           (if (equal type 'inline-src-block)
               (org-ravel-snippetize chunk-style ravelarg non-ravelargs full-body)
             (org-ravel-blockify chunk-style label ravelarg ravel-attr
                                 non-ravelargs full-body))))))
#+END_SRC
*** defun-org-ravel-snippetize/blockify

   Call the chunk-style functions to format the code.

#+NAME: defun-org-ravel-snippetize
#+BEGIN_SRC emacs-lisp
  (defun org-ravel-snippetize (chunk-style ravelarg r-headers-attr body)
    "Format an inline src block.

  Use CHUNK-STYLE, RAVELARG, and R-HEADERS-ATTR (often ignored) to
  format BODY, then wrap it inside an export snippet."
    (format "@@ravel:%s@@"
            (funcall (nth 1 chunk-style)
                     ravelarg r-headers-attr body)))

  (defun  org-ravel-blockify
    (chunk-style label ravelarg ravel-attr non-ravelargs body)
     "Format an inline src block.

  Use CHUNK-STYLE, LABEL, RAVELARG, RAVEL-ATTR and
  NON-RAVELARGS (typically ignored) to format BODY and wrap it
  inside an export block."
             (funcall (nth 0 chunk-style) label ravelarg
                      ravel-attr non-ravelargs body))
#+END_SRC
*** defun-org-ravel-get-style
#+NAME: defun-org-ravel-get-style
#+BEGIN_SRC emacs-lisp
  (defun org-ravel-get-style (style-from-header)
    "Return the chunk style for STYLE-FROM-HEADER.

  Possibly find it in properties or use `org-ravel-style' by
    default."
    (or
     (assoc-default
      (or style-from-header
          (cdr (assoc
                :ravel-style
                (org-babel-parse-header-arguments
                 (org-entry-get (point)
                                "header-args:ravel"
                                'inherit))))
          org-ravel-style)
      org-ravel-style-alist 'string=)
     (user-error "Ravel-style: %S not found -- Consult `org-ravel-style-alist'"
                 style-from-header)))

#+END_SRC

* Chunk styling

These functions will be called by the transcoders or used to set up
functions to be so called.

** defun-org-ravel-attr-plus-header
#+NAME: defun-org-ravel-attr-plus-header
#+BEGIN_SRC emacs-lisp
  (defun org-ravel-attr-plus-header
    (label ravelarg ravel-attr)
    "Separate LABEL, RAVELARG, and RAVEL-ATTR by commas."
    (mapconcat #'identity
               (delete nil
                       (cons label
                             (cons ravelarg ravel-attr))) ", "))

#+END_SRC


** defmacro-org-ravel-style-x
#+NAME: defmacro-org-ravel-style-x
#+BEGIN_SRC emacs-lisp
   (defmacro org-ravel-style-x (x xblock xinline &optional xcode)
     "Make style functions.

  The functions are `org-ravel-block-X' and `org-ravel-inline-X'
  where X names the style, XBLOCK gives the block format, XINLINE gives the
  inline format, and XCODE is an optional line prefix.

   `org-ravel-block-X' defines the Chunk code style.  It's arguments are
       LABEL - the chunk name,
       RAVEL - header args as a string,
       ATTR-RAVEL - attributes to be combined with RAVEL,
       R-HEADERS-ATTR - other headers from Babel as a string parseable
        by `org-babel-parse-header-arguments',
       SRC-CODE is the code from the block.

   `org-ravel-inline-X' defines the inline code style.  It's arguments
       are RAVEL, R-HEADERS-ATTR, SRC-CODE as above.  Note that only SRC-CODE is
       used in this macro, but other arguments may be used in hand tooled inline
       style functions."
     (let ((blk-args
            '(label ravel attr-ravel r-headers-attr src-code))
           (inline-args '(ravel r-headers-attr src-code))
           (blk-body
            `(let ((ravel  (org-ravel-attr-plus-header label ravel attr-ravel)))
               ,(if xcode
                    `(format ,xblock ravel
                             (replace-regexp-in-string "^" ,xcode src-code))
                  `(format ,xblock ravel src-code))))
           (inline-body `(format ,xinline src-code))
           (bname (concat "org-ravel-block-" x))
           (iname (concat "org-ravel-inline-" x)))
       (defalias (intern bname)
         (list 'lambda blk-args blk-body)
         (concat "Run this:\n\n" (pp-to-string blk-body)))
       (defalias (intern iname)
         (list 'lambda inline-args inline-body)
         (concat "Run this:\n\n" (pp-to-string inline-body)))
       (format "Functions: %s and %s" bname iname)))

#+END_SRC
** brew-style

Brew needs to wrap the code inside "<% ... %>" and possibly add
additional markup. So the `org-ravel-style-x' macro is not used to
produce the `org-ravel-block/inline-brew' functions.

*** defun-org-ravel-format-brew-spec
#+NAME: defun-org-ravel-format-brew-spec
#+BEGIN_SRC emacs-lisp
  (defun org-ravel-format-brew-spec (&optional spec)
    "Check a brew SPEC, escape % signs, and add a %s spec."
    (let
        ((spec (or spec "<% %>")))
      (if (string-match
           "<\\(%+\\)\\([=]?\\)\\(.+?\\)\\([{}]?[ ]*-?\\)\\(%+\\)>"
           spec)
          (let (
                (opct (match-string 1 spec))
                (eqsign (match-string 2 spec))
                (filler (match-string 3 spec))
                (enddash (match-string 4 spec))
                (clpct (match-string 5 spec)))
            (if (string= opct clpct)
                (concat "<" opct opct eqsign " %s " enddash clpct clpct ">")
              (error "Percent signs do not balance:%s" spec)))
        (error "Invalid spec:%s" spec))))

#+END_SRC

*** defun-org-ravel-block-brew
#+NAME: defun-org-ravel-block-brew
#+BEGIN_SRC emacs-lisp
  (defun org-ravel-block-brew (label ravel attr_ravel r-headers-attr src-code)
    "Define the chunk style for brew.

  LABEL is the chunk name, RAVEL is the collection of ravel args as
  a string, ATTR_RAVEL and R-HEADERS-ATTR are ignored here,
  SRC-CODE is the code from the block."
    (format (org-ravel-format-brew-spec ravel) src-code))

  (defun org-ravel-inline-brew (ravel r-headers-attr src-code)
    "Define the inline-src style for brew.

  RAVEL is the collection of ravel args as a string, R-HEADERS-ATTR
  is the collection of headers from Babel as a string parseable by
  `org-babel-parse-header-arguments', SRC-CODE is the code from the
  block."
    (format (org-ravel-format-brew-spec
             (or ravel "<%= code -%>"))
            src-code))

#+END_SRC
** standard block/inline chunk styles

See the `org-ravel-style-x' docstring for more details.

*** org-ravel-style-x-rnw
#+NAME: org-ravel-style-x-rnw
#+BEGIN_SRC emacs-lisp
  (org-ravel-style-x "rnw"
  "<<%s>>=\n%s\n@ %%def"
  "\\Sexpr{ %s }")
#+END_SRC
*** org-ravel-style-x-tex
#+NAME: org-ravel-style-x-tex
#+BEGIN_SRC emacs-lisp
  (org-ravel-style-x "tex"
                     "%% begin.rcode( %s )\n%s\n%% end.code"
                     "\\rinline{ %s }"
                     "%")
#+END_SRC
*** org-ravel-style-x-html
#+NAME: org-ravel-style-x-html
#+BEGIN_SRC emacs-lisp
  (org-ravel-style-x "html"
  "<!--begin.rcode  %s \n%s\nend.rcode-->"
  "<!--rinline  %s  -->")
#+END_SRC
*** org-ravel-style-x-md
#+NAME: org-ravel-style-x-md
#+BEGIN_SRC emacs-lisp
  (org-ravel-style-x "md"
  "```{r  %s }\n%s \n```"
  "`r  %s `")


#+END_SRC
*** org-ravel-style-x-braces
#+NAME: org-ravel-style-x-braces
#+BEGIN_SRC emacs-lisp
  (org-ravel-style-x "braces"
  "{{%0.0s%s}}"
  "{{%s}}")

#+END_SRC
* Exporter
** Transcoders

Transcoders for `export-block' and `export-snippet' are defined for
the ravel family of backends. For `ravel' blocks/snippets, they merely
return their content. For other blocks/snippets, they fall back to the
transcoders for the parent backend.

*** TODO defun-org-ravel-export-block now special-block is REVERTED
:TODO:

- ANN :: http://lists.gnu.org/archive/html/emacs-orgmode/2014-08/msg01007.html

- reverted :: export-blocks are deprecated --- use special blocks
              instead. `org-ravel-special-block' implements this.

Note that I do not query org-export-raw-special-block-p, because this
is implied for ravel - it might be necessary to leave the old export
block transcoder in place for back compatibility


Porbably this does not matter - why would an on-the-fly backend be used
without having any ravele backends registered:  on the fly backends
need to have RAVEL entry in `org-element-block-name-alist' iff there
are not ravel backends registered - or the special block transcoder
needs to handle them

But now I have doctored org-ravel-special-block to allow for this
possibility.

I have just [2014-09-15 Mon] added a :blocks entry to
org-ravel-create-backend, but it does not alter the alist...
and maybe should not.

:END:

#+NAME: defun-org-ravel-special-block
#+BEGIN_SRC emacs-lisp
  (defun org-ravel-special-block (special-block contents info)
    "Transcode a SPECIAL-BLOCK element from Org to ravel.
  CONTENTS is nil.  INFO is a plist holding contextual information."
    (if (equal (org-element-property :type special-block) "RAVEL")
        contents
      (let ((parent-backend (org-export-backend-parent backend)))
        (if parent-backend
            (org-export-with-backend
             parent-backend special-block contents info)))))

#+END_SRC


#+NAME: defun-org-ravel-export-block
#+BEGIN_SRC emacs-lisp
  (defun org-ravel-export-block (export-block contents info)
    "Transcode a EXPORT-BLOCK element from Org to ravel.
  CONTENTS is nil.  INFO is a plist holding contextual information."
    (if (equal (org-element-property :type export-block) "RAVEL")
	(org-element-property :value export-block)
      (let ((parent-backend (org-export-backend-parent backend)))
        (if parent-backend
            (org-export-with-backend
             parent-backend export-block contents info)))))



#+END_SRC
*** defun-org-ravel-export-snippet
#+NAME: defun-org-ravel-export-snippet
#+BEGIN_SRC emacs-lisp
  (defun org-ravel-export-snippet (export-snippet contents info)
    "Transcode a EXPORT-SNIPPET element from Org to ravel.
  CONTENTS is nil.  INFO is a plist holding contextual information."
    (if (eq (org-export-snippet-backend export-snippet) 'ravel)
	(org-element-property :value export-snippet)
      (let ((parent-backend (org-export-backend-parent backend)))
         (if parent-backend
             (org-export-with-backend
              parent-backend export-snippet contents info)))))

#+END_SRC
** export to file, to buffer, string as string


*** defun-org-ravel-create-backend
#+BEGIN_SRC emacs-lisp
  (defun  org-ravel-create-backend (parent &optional style)
    "Create a ravel-compliant backend from PARENT using STYLE.
  Hence, (org-ravel-create-backend 'ascii \"md\") creates a backend
  whose parent is ascii and default style is \"md\"."
    (org-export-create-backend
     :parent parent
     :transcoders '((export-snippet . org-ravel-export-snippet)
                    (export-block . org-ravel-export-block)
                    (special-block . org-ravel-special-block))
     :options `((:ravel-style "RAVEL_STYLE" nil ,style t))
     :blocks    '("RAVEL")))

#+END_SRC
*** defun-org-ravel-export-string-as
#+NAME: defun-org-ravel-export-string-as
#+BEGIN_SRC emacs-lisp
  (defun org-ravel-export-string-as
    (string backend &optional body-only ext-plist engines style)
    "Export STRING as a string.

   Use BACKEND with BODY-ONLY and EXT-PLIST, all as per
  `org-export-string-as'.  If non-nil, ENGINES will set
  `org-ravel-run' locally.  Otherwise, an attempt will be made to
  replace it with `org-ravel-run' or `org-ravel-engines'.  STYLE
  will set `org-ravel-style' if non-nil, otherwise
  `org-ravel-style' or the default for BACKEND will be used.  

  This function can be run by Babel to produce a string that is
  used in a Babel src block.

  It can run arbitrary backends if STYLE is supplied or if STRING
  supplies valid values for src blocks and inline src blocks in it."

    (let* ((org-ravel-run
            (or engines org-ravel-run org-ravel-engines))
           (bk-orig
            (if (symbolp backend)
                (org-export-get-backend backend) backend))
           (ravel-block
            (member "RAVEL"
                    (org-export-backend-blocks bk-orig)))
           (backend (if ravel-block bk-orig
                      (unless style
                        (message "Non ravel BACKEND might need STYLE."))
                      (org-ravel-create-backend
                       (org-export-backend-name bk-orig) style)))
           (org-ravel-style
            (or style org-ravel-style
                (nth 3
                     (assoc :ravel-style
                            (org-export-backend-options
                             backend)))))
           (org-confirm-babel-evaluate org-confirm-babel-evaluate))
      (org-ravel-reset-confirm
       org-ravel-no-confirm-for-ravel)
      (org-export-string-as string backend body-only ext-plist)))

#+END_SRC
*** defun-org-ravel-export-to-file

#+NAME: defun-org-ravel-export-to-file
#+BEGIN_SRC emacs-lisp
  (defun org-ravel-export-to-file
    (backend &optional file async subtreep visible-only
             body-only ext-plist post-process engines style)
    "Export invoking ravel with BACKEND to FILE.

  ASYNC must be nil, but SUBTREEP, VISIBLE-ONLY, BODY-ONLY,
  EXT-PLIST, and POST-PROCESS are passed to `org-export-to-file'.
  ENGINES supplies a value for `org-ravel-run' and STYLE for
  `org-ravel-style'.  If a backend is used that is not set up for
  ravel, it usually best to use, e.g.

       `(org-ravel-export-to-file
         (org-ravel-create-backend 'ascii \"md\") ... )'

    to create a ravel-compliant backend.

  Note that `org-babel-confirm-evaluate' is set locally by `let*'
  to `org-ravel-no-confirm-for-ravel', which holds a `lambda'
  function.  To override this, create a variable with that name."

    (let* ((org-ravel-run
            (or engines org-ravel-run org-ravel-engines))
           (backend (if (symbolp backend)
                        (org-export-get-backend backend)
                      backend))
           (org-ravel-style
              (or style org-ravel-style
                  (nth 3
                       (assoc :ravel-style
                              (org-export-backend-options
                               backend)))))
           (org-confirm-babel-evaluate t)
           (file (or file
                     (org-export-output-file-name
                      (org-ravel-extension org-ravel-style) subtreep))))
      (when async (user-error "ASYNC not allow for ravel"))
      (org-ravel-reset-confirm
       org-ravel-no-confirm-for-ravel)
      (org-export-to-file backend file async subtreep visible-only
                          body-only ext-plist post-process)))

#+END_SRC
*** defun-org-ravel-export-to-buffer

#+NAME: defun-org-ravel-export-to-buffer
#+BEGIN_SRC emacs-lisp
  (defun org-ravel-export-to-buffer
      (backend &optional buffer async subtreep visible-only
               body-only ext-plist post-process engines style)
    "Export invoking ravel using BACKEND to BUFFER.

  ASYNC must be nil, but SUBTREEP, VISIBLE-ONLY, BODY-ONLY,
  EXT-PLIST, and POST-PROCESS are passed to `org-export-to-buffer'.
  ENGINES supplies a value for `org-ravel-run' and STYLE for
  `org-ravel-style'.  If a backend is used that is not set up for
  ravel, it usually best to use, e.g.

     `(org-ravel-export-to-buffer
       (org-ravel-create-backend 'ascii \"md\") ... )'

  to create a ravel-compliant backend.

  Note that `org-babel-confirm-evaluate' is set locally by `let*'
  to `org-ravel-no-confirm-for-ravel', which holds a `lambda'
  function.  To override this, create a variable with that name."
  
    (let* ((org-ravel-run
            (or engines org-ravel-run org-ravel-engines))
           (backend (if (symbolp backend)
                        (org-export-get-backend backend)
                      backend))
           (org-ravel-style
            (or style org-ravel-style
                (nth 3
                     (assoc :ravel-style
                            (org-export-backend-options
                             backend)))))
           (org-confirm-babel-evaluate t)
           (buffer (or buffer
                       (format "* %S Output *"
                               (org-export-backend-name backend)))))
      (when async (user-error "ASYNC not allow for ravel"))
      (org-ravel-reset-confirm
       org-ravel-no-confirm-for-ravel)
      (org-export-to-buffer backend buffer async subtreep visible-only
                            body-only ext-plist post-process)))

#+END_SRC

** Backend Definitions
   

*** defun-org-ravel-extension
#+NAME: defun-org-ravel-extension
#+BEGIN_SRC emacs-lisp
  (defun org-ravel-extension (style)
    "Get the file extension for STYLE."
    (nth 3 (assoc-string style org-ravel-style-alist)))


#+END_SRC

*** defmacro-ravel-define-exporter

#+NAME: defmacro-ravel-define-exporter
#+BEGIN_SRC emacs-lisp
    (defmacro org-ravel-define-exporter
      (ravel-backend parent menu-key menu-label style-default
                     &optional fileout bufferout post-proc)
      "Define ravel backends.

    The arguments are:

           RAVEL-BACKEND is a symbol naming the backend derived from

           PARENT is a registered backend,

           MENU-KEY should be an integer code for a lower-case
           character like `?a' to refer to file dispatch,

           MENU-LABEL tells how to label the backend in the
           dispatch menu,

           STYLE-DEFAULT is the style to use if not specified as a
            `:ravel-style' attribute,

           FILEOUT is usually nil which allows
           `org-ravel-export-to-file' to assign the file name

           BUFFEROUT is usually `t' - if non-nil create menu
           entry `(upcase MENU-KEY)' that will be used for menu
           dispatch) or nil for no buffer dispatcher, and

           POST-PROC is a post-export hook function or nil."

      `(org-export-define-derived-backend
           ,ravel-backend
           ,parent
           :translate-alist '(
                              (export-snippet . org-ravel-export-snippet)
                              (export-block . org-ravel-export-block)
                              (special-block . org-ravel-special-block))
           :options-alist '((:ravel-style "RAVEL_STYLE"
                                          nil ,style-default t))
           :export-block    '("RAVEL")      
           :menu-entry
           '(?r "Ravel"
                ,(remq nil
                       `((,menu-key ,(concat menu-label " file")
                                    (lambda (a s v b)
                                      (org-ravel-export-to-file
                                     ,ravel-backend ,fileout a s v b nil 
                                     nil nil ,style-default)))
                         ,(if bufferout
                              `(,(upcase menu-key) ,(concat menu-label " buffer")
                                (lambda (a s v b)
                                  (org-ravel-export-to-buffer
                                   ,ravel-backend nil a s v b nil ,post-proc
                                   nil ,style-default)))))))))
#+END_SRC

** Create Backends

The `(eval-after-load FILE FORM)' forms seems to work. i.e. FORM is
executed if the backend specified in FILE (e.g. 'ox-latex) is already loaded.
If not, then when FILE is loaded, FORM is run.

The variable `org-export-backends' can be customized to (de-)list
parent backends. The `ravel' backends that depend on those parents are
(de-)activated when the parent is (de-)listed.

A ravel backend whose parent is not in `org-export-backends' will need
to `require' or `load' that parent.

#+NAME: run-org-ravel-define-exporters
#+BEGIN_SRC emacs-lisp :comments org

  (eval-after-load 'ox-latex
    '(org-ravel-define-exporter
     'ravel-latex
     'latex ?l "Ravel-LaTeX" "rnw" nil t (lambda () (LaTeX-mode))))

  (eval-after-load 'ox-beamer
    '(org-ravel-define-exporter
     'ravel-beamer
     'beamer ?b "Ravel-beamer" "rnw" nil t (lambda () (LaTeX-mode))))

  (eval-after-load 'ox-html
    '(org-ravel-define-exporter
     'ravel-html
     'html ?h "Ravel-html" "html" nil t ))

  (eval-after-load 'ox-md
    '(org-ravel-define-exporter
     'ravel-markdown
     'md ?m "Ravel-markdown" "md" nil t ))

#+END_SRC

* provide ravel							   :noexport:

#+BEGIN_SRC emacs-lisp :tangle ox-ravel.el
  (provide 'ox-ravel)

  ;;; ox-ravel.el ends here
#+END_SRC


