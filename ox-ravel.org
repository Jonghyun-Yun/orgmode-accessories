#+TITLE:     ox-ravel.org
#+AUTHOR:    Charles Berry
#+EMAIL:     ccberry@ucsd.edu
#+DATE:      2012-10-04
#+COMMENT: latest revision 2014-08-24
#+DESCRIPTION: Sweave/knit/brew document maker for orgmode
#+KEYWORDS:
#+LANGUAGE:  en
#+OPTIONS:   H:3 num:t toc:nil \n:nil @:t ::t |:t ^:t -:t f:t *:t <:t
#+OPTIONS:   TeX:t LaTeX:t skip:nil d:nil todo:t pri:nil tags:not-in-toc
#+INFOJS_OPT: view:nil toc:nil ltoc:t mouse:underline buttons:0 path:http://orgmode.org/org-info.js
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport
#+LINK_UP:   
#+LINK_HOME: 
#+XSLT:
#+DRAWERS: DEVNOTES TODOWHAT
#+PROPERTY: tangle ox-ravel.el

* Background
  :PROPERTIES:
  :eval:     never
  :END:
** browsing this file

~ox-ravel.org~ is an orgmode file. 

If you are browsing ~github~, you
should probably look at the file ~ravel-org.md~ which is formatted for viewing
(and omits lots of details that are usually not of interest). 

If you have downloaded a copy of ~ox-ravel.org~, it is best to view it using [[orgmode][orgmode]]
  
** quickstart guide

If you already know ~orgmode~ and either ~knitr~, ~Sweave~, or
~brew~, you can just

- skip to [[lisp setup]["lisp setup"]] to install ravel
- browse one or more [[examples][examples]]
  - you can type =C-c C-e r <letter>= (where =<letter>= is one of the
    listed menu items) in those files to try out the exporter
- review the section [[what ravel does]["what ravel does"]]

** orgmode

[[http://orgmode.org/index.html][Orgmode]] is /for keeping notes, maintaining TODO lists, doing project planning, and authoring with a fast and effective plain-text system./ The same org document can be used to create LaTeX, HTML, plain ASCII, and various other formats upon export.

[[http://orgmode.org/worg/org-contrib/babel/index.html][Babel]] is /Org-mode's ability to/ /execute source code/ /within Org-mode documents/. It is powerful and flexible and a useful tool for generating reproducible research reports as outlined in [[http://www.jstatsoft.org/v46/i03][the report :]] Eric Schulte, Dan Davison, Thomas Dye, and Carsten Dominik. A Multi-Language Computing Environment for Literate Programming and Reproducible Research. Journal of Statistical Software. 46(3) Jan 2012. Source code blocks can be editted in place or in a language major-mode edit buffer containing the body of the code block. And for R blocks, ~ESS~ is fully functional.

** R document/report Generators 

There are many markup and report and document generating packages and
functions for R. A useful overview of them is at [[http://cran.r-project.org/web/views/ReproducibleResearch.html][CRAN Task View for
Reproducible Research]]

Several to which this software is aimed are 

   - Sweave :: This R function is the basic workhorse for many report
               and document generating functions. It uses (by default)
               a noweb type syntax to separate code chunks from LaTeX
               markup and can be run to /weave/ reports or /tangle/
               executable code.. It described in
               detail at
     - [[http://www.statistik.uni-muenchen.de/~leisch/Sweave/][the Sweave homepage]] and in
     - Friedrich Leisch. Sweave: Dynamic generation of statistical
       reports using literate data analysis. In Wolfgang Härdle and
       Bernd Rönz, editors, Compstat 2002 - Proceedings in
       Computational Statistics, pages 575-580. Physica Verlag,
       Heidelberg, 2002. ISBN 3-7908-1517-9.
       

   - brew :: This R package uses a simple PHP-like syntax to markup
               documents mixing text and code which are then through
               the ~brew()~ function. It is described in the help documents for the package: 
       - Jeffrey Horner (2011). brew: Templating Framework for Report
         Generation. R package version 1.0-6.
         http://CRAN.R-project.org/package=brew

   - knitr :: This R package is an attempt to combine and unify the
                 best features of many report generating/markup
                 package and functions in R. It is described in

	 - Yihui Xie (2012). knitr: A general-purpose package for
           dynamic report generation in R. R package version 0.6.3.
           http://CRAN.R-project.org/package=knitr and

	 - [[http://yihui.name/knitr/][The knitr home page]]

** Putting orgmode and Sweave together

Each approach (orgmode as report generator vs Sweave-like report
generators) has its own strengths and weaknesses.

After years of using Sweave for report creation, I tried to use
orgmode to construct a research report from a moderate sized database
using some simulations and lengthy statistical resampling routines. I
got through the first draft of the report and a 25-page supplement
using orgmode/Babel.

I really liked the ease with which I could organize some things in the
process - like notes, emails from collaborators, TODO lists, and code
snippets and intermediate results that might not show up in the final
report or supplement or whose location was uncertain. Being able to
run code snippets and have the results saved in the master document
and be able to toggle to view LaTeX snippets and graphics rendered in
place was very slick.

However, there were some things I really missed that were helpful in
the Sweave style of work. There are /dependency aware/ caching systems
in R that are simple and powerful; you can change a line of code and
rerun the document and all the pieces that need to be recomputed are
rebuilt and recached. And it all happens in a flash if all you needed
to do was change a format in table or anything that doesn't require a
large object to be rebuilt. And when a large object is rebuilt, all
its dependencies get updated, too. I ended up building a collection of
intermediate R objects to make the build/revision process execute in
finite time, but maintaining them and rebuilding them as needed was a
nuisance. Some componenents of the project required only a subset of
objects and the R packages that access them and I ended up having to
sprinkle links to the code to ~load~ or ~require~ throughout the
orgmode file. In the end, the orgmode files that served as the master
and the supplement were more than 7500 lines long and had more than
130 R source code blocks. And to be honest, there were some
stand-alone R scripts and a separate org file that had over 100 source
code blocks in to to manange the CPU intensive computations. It ended
up being pretty ungainly.

Also, there are some nice formatting tools available and more coming
into use. And many of them are hard (or maybe impossible) to use when
Babel is doing the final report generation. I did use =brew= under
Babel, but it was truly an awkward process.

I saw terrific possibilities presented by new (as of July 2012) R
packages in development like [[http://yihui.name/knitr/][=knitr=]] and [[https://github.com/daroczig/pander][=pander=]]. I switched to
=knitr= for several recent projects, but I wanted to retain the
features of orgmode+Babel for my workflow. The Org export engine (see
the Org manual [[http://orgmode.org/org.html#Exporting][Exporting]] section or [[http://orgmode.org/worg/dev/org-export-reference.html][Org Export Reference
Documentation]]) made it possible to have a workstyle in which an
orgmode master document contains a /subtree/ with text and code blocks
that when exported becomes a knitr, Sweave or brew style document that
when run produces LaTeX, HTML, and/or some other markup language. By
including caching options in those documents the development process
becomes easy to organize, restarting work after a break is just a
matter of rerunning the document to load the cached objects and
libraries, then switching to the orgmode master to try out some new
code, reorganize the presentation, and so on.


* lisp setup
  :PROPERTIES:
  :eval:     never
  :CUSTOM_ID: lispset
  :END:
  
** extract ox-ravel.el and load it 
   
   These two lines should do the trick:
   
#+BEGIN_SRC emacs-lisp :tangle no
(org-babel-tangle)
(load-file "ox-ravel.el")
#+END_SRC
 
Now you can use ravel.
  
** Install ox-ravel

For everyday use, move =ox-ravel.el= into your load path,
e.g. =~/.emacs.d/= or =~/elisp/= and add ~(require 'ox-ravel)~ to your
startup.

* examples

Some =*.org= files in this directory show how the available backends
can be used. Check out

 - =demos.org= :: simple examples.
 - =test-cases.org= :: comparison of plain latex and latex with chunks
      rendered in the =rnw= and =brew= styles.
 - =example-1-Rnw.org= :: an org version =example-1.Rnw= from the R =utils= package.
 - =knitr-minimal-rhtml.org= :: an org version of =003-minimal.Rhtml=
 from =github.com/yihui/knitr-examples/=
* ravel
  :PROPERTIES:
  :eval:     never
  :END:
  
  :DEVNOTES:
Things to think about:
- load, require, autoload, provide
- Commentary and Code as per checkDoc
- dexy does integration of documents, see [[http://www.dexy.it/faq/#how-is-dexy-different-to-sweave][Dexy FAQ]], maybe later ...

- melpa might be a good way to distribute: [[http://melpa.milkbox.net/][MELPA homepage]]

- DO flet: use org-flet instead - [2012-08-17 Fri] HUH? org-flet is
  gone!!! Back to plain old flet. Push this to github along with other
  new stuff.

- DONE: I have set up to combine :ravel and #+ATTR_RAVEL: then 
 
- Save the header info as #+ATTR_R-HEADERS: then parse the header info in
  the src block function and
  possibly refer to its values in setting up the chunk.

- exporting brew style to *.org might be an awesome capability. Here is how to do it:
  1. write the usual code including `:ravel <%[=] ... [{}][-]%>' arguments
     - install a hook for org-export-before-parsing-hook that will
     - (copy and) save the temp buffer
     - run R and call brew( <the saved copy> )
     - ad-deactivate as needed
     - (stop "all done") or
     - copy the saved buffer back to working buffer and continue. Under
       this option, one can later use the saved buffer to export to
       other formats
     - then just export with any backend that supports brew
  2. put brew delimiters in an *.org file
     - run brew on that file and write another file
     - export that file as usual, possibly letting babel work as usual


Mostly DONE:
- so here is what I am figuring out:
  - DONE need to advise org-babel-exp-do-export
    - to strip results of R blocks
    - to pre-format R src-blocks and inline src blocks
    - to pre-format and possibly run non-R source blocks according to
      the original parent (e.g. latex)
  - DONE advise org-export-as to
    - add hook for pre-parsed buffer
    - ad-activate org-babel-exp-do-export
    - ad-do-it
    - remove hook for pre-parsed buffer
    - ad-deactivate
    so that other back-ends are not tripped up
  - DONE define a universal src-block function
  - DONE define a universal inline-src-block function
  - define a back-end specific src-block format [DONE for latex-brew
    and latex-noweb]
  - define a back-end specific inline-src-block format [LIKEWISE]
  - DONE for the non-R src block function, use the ancestral version
  - DONE for the non-R inline src block function, use ancestor
  - NB ( assoc 'src-block (reverse org-rnw-translate-alist)) will
    find the ancestor!!!! - might need to revise for multiply derived
    backends like ox-md.
  - NB org-export-before-parsing-hook is handy - it can remove delimiters
    I insert to subvert babel's machinations.
  - need to add a native knitr backend
  - DONE src_R{} idiom is tricky. org-babel-inline-src-block-regexp
    needs whitespace between the [args] if any in the src_R call. So,
    I add that in the flet'ed version of org-babel-execute:R.

:END:
  
  :DEVNOTES:

Here is the elisp header for ox-ravel.el

#+BEGIN_SRC emacs-lisp :tangle ox-ravel.el
  ;;; ox-ravel.el --- Sweave/knit/brew document maker for orgmode
  ;; Copyright (C) 2012,2014  Charles C. Berry
  
  ;; This program is free software: you can redistribute it and/or modify
  ;; it under the terms of the GNU General Public License as published by
  ;; the Free Software Foundation, either version 3 of the License, or
  ;; (at your option) any later version.
  
  ;; This program is distributed in the hope that it will be useful,
  ;; but WITHOUT ANY WARRANTY; without even the implied warranty of
  ;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  ;; GNU General Public License for more details.
  
  ;; You should have received a copy of the GNU General Public License
  ;; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  
  ;;; Commentary: 
  ;;              See ox-ravel.org for details.
  ;;
  ;;; Code:
  ;;
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle ox-ravel.el
  (require 'ox)
#+end_src

#+END_SRC
:END:

  
** using and extending ravel
   
*** what ravel does

~ravel~ allows exporting ~*.org~ files or subtrees in them to several
reproducible research formats: ~brew~, ~Sweave~, and several ~knitr~
formats (brew, Rnw, Rmd, and Rhtml).

With ~ox-ravel-el~ loaded and the point in a =*.org= buffer, 

: C-c C-e

or

: M-x org-export-dispatch RET

will pop up a menu of choices. Optionally, type ~C-s~ to select the
subtree containing point. Then type =r= to select the =Ravel= menu.
The keys on that menu allow export to one of the formats supported by
~ravel~.

~ravel~ exports the file or subtree in a suitable format
(currently LaTeX, HTML, or Markdown), but with differences from the
usual export mechanism in which the source code (aka src blocks) are
evaluated by orgmode's Babel engine and (optionally) code and/or
results are passed to the exporter.

Before the document is parsed, Babel is run. However, R src blocks are
not evaluated in the usual way. Instead they are processed as if they
were ~ravel~ language src blocks. The ~ravel~ language takes a block
of code and marks it up to define chunks according to the convention
of Sweave, knitr, or some other report generator.  Src blocks with the
~:noweb yes~ header argument are expanded (by inserting the code from
the blocks in the noweb references) before being marked up.  R src
blocks that have the ~:exports none~ header argument are ignored. Src
blocks in other languages are evaluated and exported as usual.

Thus, a document can define many R src blocks and select a few to
export by constructing a subtree with src blocks that include noweb
references in them and for which ~:noweb yes~ is specified. Then, just
that subtree can be exported. 

An R header argument named ~:ravel~ and ~:attr_ravel~ properties are
passed to the exporter for use as options in the ultimate code
chunks. So, ~knitr~ chunk options such as 'results="as.is"' would be
given as ~ravel~ arguments. The way these are handled depends on the
backend; for ~knitr~ they are placed as chunk options and for ~brew~
they are used to construct variants of the '<% ... %>' code
delimiters.

Once Babel is finished, the exporter takes over. Typically, an export
backend is dierived from an existing backend like ~latex~, and
merely adds transcoders for handling the marked up src blocks or
inline src, and menu selections.

*** existing backends

Currently, backends are avaiable for 

- ~ravel-latex~ :: LaTeX Sweave, knitr, or brew documents
- ~ravel-beamer~ :: LaTeX Sweave and knitr beamer documents
- ~ravel-markdown-~ :: Markdown knitr documents
  - ~ravel-html~ :: HTML knitr/Rhtml documents


A look at the ~*.org~ files in [[examples][the examples section]] should provide a
quickstart.  A look (below) at the definitions of the style functions
for these backends should guide further devlopment.

*** explicit specification of arguments in exported chunks

Arguments that need to be passed to exported code chunks can be placed
after a ~:ravel~ key in a ~#+begin_src R~ line. Or they can be given
in ~#+ATTR_RAVEL:~ lines immediately before the src block. 

Some care is needed. Arguments for some backends may conflict with
other backends. In future development, it might help to prefix
arguments with the name of their backend.
 
*** TODO using Babel header arguments in exported code chunks
:TODOWHAT:
revise the sr blk?
:END:

Babel header as a string parseable by
`org-babel-parse-header-arguments' are made available to the
~org-ravel-blockify~ function in the ~non-ravelargs~ argument. This
would allow translation of some org-babel R header arguments
to exported chunk headers.  `org-ravel-style-list' defines the
allowable styles for chunks and adding to that list allows for special
handling of Babel header args.  The src block and inline processing
functions of a style would need to inspect the alist of
~r-headers-attr~ and find those that can be (re-)rendered and add the
necessary arguments to the output string in the header position along
with the arguments provided by the ~ravel~ argument.

*** new backends

A new =ravel= backend can be created with the function
`org-ravel-define-exporter'. See its docstring for more details.The
~ravel-markdown~ exporter was defined using the code in the next src
block.


#+BEGIN_SRC emacs-lisp :exports code :tangle no
  (org-ravel-define-exporter
   'ravel-markdown 
   'md ?m "Ravel-markdown" "md" nil t )
#+END_SRC


It is fairly easy to add more backends. There are these
ingredients needed:

1. chunk style function - usually chosen from `org-ravel-style-alist'
2. inline style function - ditto
3. a call to setup up the derived backend
4. (optionally) a function to work with the ~org-export-dispatch~ menu
 
The examples below should serve to show what is needed to create
different chunk and inline styles.

* TODO Babel

** variables
*** defconst-org-babel-header-args:ravel
#+NAME: defconst-org-babel-header-args:ravel
#+BEGIN_SRC emacs-lisp
  (defconst org-babel-header-args:ravel
    '(
      (ravel               . (:any))
      (ravel-style         . :any)
      (engine              . :any)
      (exports             . :any)
      (results             . ((file list vector table scalar verbatim)
                              (raw org html latex code pp wrap)
                              (replace silent append prepend)
                              (output value graphics))))
    "Ravel-specific header arguments.")
#+END_SRC
*** defvar-org-ravel-style

#+NAME: defvar-org-ravel-style
#+BEGIN_SRC emacs-lisp
  (defvar org-ravel-style nil
    "The default style to use for constructing chunks. Can be
  buffer-local, and is usually set by the export dispatcher.")

  (make-variable-buffer-local 'org-ravel-style)
#+END_SRC
*** defvar-org-ravel-run

#+NAME: defvar-org-ravel-run
#+BEGIN_SRC emacs-lisp
  (defvar-local org-ravel-run nil
    "If ravel is to be run on src blocks, this will be a list like

         '(\"R\") or '(\"R\" \"python\" \"awk\")

  and usually set (by the export dispatcher) to `org-ravel-engines'.

  Set this as buffer/file local for demos or debugging.")

#+END_SRC

*** defcustom-org-ravel-engines


#+NAME: defcustom-org-ravel-engines
#+BEGIN_SRC emacs-lisp

  (defcustom org-ravel-engines '("R")
    "The engines to use in forming ravel chunks. Typically,
  `org-ravel-run' will default to these.  Current knitr recognizes
  these engines: 

        `R' `python' `awk' `ruby' `haskell' `bash' `perl' `dot'
         `tikz' `sas' `coffeescript' and `polyglot'."
   :group 'org-export-ravel

   :type '(set :greedy t
               (const :tag "   R" "R" )
               (const :tag "   Python" "python" )
               (const :tag "   AWK" "awk" )
               (const :tag "   Ruby" "ruby" )
               (const :tag "   Haskell" "haskell" )
               (const :tag "   bash" "bash" )
               (const :tag "   perl" "perl" )
               (const :tag "   dot" "dot" )
               (const :tag "   TikZ" "tikz" )
               (const :tag "   SAS" "sas" )
               (const :tag "   CoffeeScript" "coffeescript" )
               (const :tag "   Polyglot" "polyglot" )
               (string  :tag "   Other")))



#+END_SRC

*** TODO setq-org-ravel-style-alist
:TODOWHAT:
use `defcustom' here 
:END:

#+NAME: setq-org-ravel-style-alist
#+BEGIN_SRC emacs-lisp
  (setq org-ravel-style-alist
       '((rnw . (org-ravel-block-rnw org-ravel-inline-rnw ".Rnw"))
        (brew . (org-ravel-block-brew org-ravel-inline-brew ".Rbrew"))
        (tex  . (org-ravel-block-tex org-ravel-inline-tex ".Rtex"))
        (html . (org-ravel-block-html org-ravel-inline-html ".Rhtml"))
        (md   . (org-ravel-block-md org-ravel-inline-md ".Rmd"))
        (braces   . (org-ravel-block-braces org-ravel-inline-braces ".Rtmpl"))
        (rst  . (org-ravel-block-rst org-ravel-inline-rst ".Rrst"))))
#+END_SRC


#+NAME: defcustom-org-ravel-style-alist
#+BEGIN_SRC emacs-lisp :tangle no
    (defgroup org-export-ravel nil
      "Options for exporting Org mode files via Ravel."
      :tag "Org Export Ravel"
      :group 'org-export)

  (defcustom org-ravel-style-alist
    '((rnw . (org-ravel-block-rnw org-ravel-inline-rnw ".Rnw"))
      (brew . (org-ravel-block-brew org-ravel-inline-brew ".Rbrew"))
      (tex  . (org-ravel-block-tex org-ravel-inline-tex ".Rtex"))
      (html . (org-ravel-block-html org-ravel-inline-html ".Rhtml"))
      (md   . (org-ravel-block-md org-ravel-inline-md ".Rmd"))
      (rst  . (org-ravel-block-rst org-ravel-inline-rst ".Rrst")))
    "The Chunk Style Alist to use in formatting Ravel output.

  The key of each element is matched by the `:ravel-style' property
  of a document, if specified, or by the default `:ravel-style' of
  the exporter selected.

  The value of each pair is a list of three elements:
    - the function that formats src blocks
    - the function that formats inline src blocks
    - a string giving the file extension. "
    :group 'org-export-ravel
    :type '(alist
            :key-type (symbol :tag "Ravel Style")
            :value--type (list :tag "Chunk Defn"
                               (function :tag "block coder")
                               (function :tag "inline coder")
                               (string :tag "File extension"))))

#+END_SRC


** TODO functions, macros,  and advice
:TODO:
Or maybe not...

After http://thread.gmane.org/gmane.emacs.orgmode/87533/focus=87845
patches are accepted, convert the code below to use :exports code, so
`org-babel-exp-do-export' will use `org-babel-exp-code' instead of
running `org-babel-exp-results'. Simplifies a lot.
- no need to change :lang ravel
- no need to set :results raw
- cleaning old results is automagic
Need to do:
- advice org-babel-exp-code to
  - call org-babel-expand-src-block to do :var assignment
  - noweb expansion just works
  - apply the chunk style functions as per --snippetize/blockify
  - let-bind org-babel-exp-code-template if (member lang engines)
  - let-bind org-babel-exp-inline-code-template if (member lang engines)
:END:

*** defadvice-org-babel-parse-inline-src-block-match

#+NAME: defadvice-org-babel-parse-inline-src-block-match
#+BEGIN_SRC emacs-lisp
  (defadvice org-babel-parse-inline-src-block-match 
    (after org-ravel-change-inline-lang activate)
    "Turn lang to ravel and add `:engine' header  maybe."
    (if 
        (org-ravel-engine-to-ravel ad-return-value)
        (org-ravel-set-raw-results ad-return-value)))
#+END_SRC

#+RESULTS: defadvice-org-babel-parse-inline-src-block-match
: org-babel-parse-inline-src-block-match

*** defadvice-org-babel-parse-src-block-match
#+NAME: defadvice-org-babel-parse-src-block-match
#+BEGIN_SRC emacs-lisp
  (defadvice org-babel-parse-src-block-match
    (after org-ravel-change-sb-lang activate)
    "Turn lang to ravel, add `:engine' header, and :wrap ravel maybe."
    (if (org-ravel-engine-to-ravel ad-return-value)
        (org-ravel-rewrap ad-return-value)))
#+END_SRC

#+RESULTS: defadvice-org-babel-parse-src-block-match
: org-babel-parse-src-block-match

*** defalias-org-babel-expand-body

#+NAME: defalias-org-babel-expand-body:ravel
#+BEGIN_SRC emacs-lisp
  (defalias 'org-babel-expand-body:ravel 'org-babel-expand-body:R
    "Do what R does here."
  )
#+END_SRC
*** defun-org-ravel-engine-to-ravel

#+NAME: defun-org-ravel-engine-to-ravel
#+BEGIN_SRC emacs-lisp
  (defun org-ravel-engine-to-ravel (retval)
    "Maybe change lang to `ravel' in RETVAL, and if so save lang as
  `:engine' header,and force `:exports results'. See docstrings for
  `org-ravel-run' and `org-ravel-engines' to see how to make ravel
  recognize which lang-s should be handled as engines."
    (when (and (boundp 'org-ravel-run) 
               org-ravel-run 
               (member (nth 0 retval) org-ravel-run))
      (let ((nth-2-retval (nth 2 retval)))
        (add-to-list 'nth-2-retval `(:engine . ,(nth 0 retval)))
        (setf (nth 0 retval) "ravel")
        (unless (equal (cdr (assoc :exports nth-2-retval)) "none")
          (setf (cdr (assoc :exports nth-2-retval)) "results"))
        (setf (nth 2 retval) nth-2-retval))))


#+END_SRC




*** defun-org-ravel-rewrap

Wrap the results of `org-babel-execute:ravel' in a
:#+BEGIN_RAVEL ... #+END_RAVEL block.

#+NAME: defun-org-ravel-rewrap
#+BEGIN_SRC emacs-lisp
  (defun org-ravel-rewrap (retval)
    ":wrap with `ravel' maybe."
    (if (assoc :wrap (nth 2 retval))
        (setf (cdr (assoc :wrap (nth 2 retval))) "ravel")
      (setf (nth 2 retval)  (append (nth 2 retval) 
                                    '((:wrap . "ravel"))))))

#+END_SRC
*** defun-org-ravel-set-raw-results

The inline results are in ~@@ravel: ... @@~ snippets. Do not allow
further formatting.

#+NAME: defun-org-ravel-set-raw-results
#+BEGIN_SRC emacs-lisp
  (defun org-ravel-set-raw-results (retval)
    "Set (:results raw replace)."
    (if (assoc :results (nth 2 retval))
        (setf (cdr (assoc :results (nth 2 retval))) "raw replace")
      (setf (nth 2 retval)  
            (append (nth 2 retval) 
                    '((:results . "raw replace"))))))

#+END_SRC
*** defvar-org-ravel-no-confirm-for-ravel

Confirmation of ravel `execution' is a nuisance --- and no code is
actually run --- so disable confirmations for `ravel' src blocks.
This can be overridden by `(setq org-ravel-no-confirm-for-ravel t)' if
ever needed.


Maybe need to add check if (functionp org-confirm-babel-evaluate) is
nil in which case, I do not reset it.

#+NAME: defvar-org-ravel-no-confirm-for-ravel
#+BEGIN_SRC emacs-lisp
  (defvar org-ravel-no-confirm-for-ravel
    (lambda (language body)
      (if (string= language "ravel") nil t))
    "Do not confirm if LANGUAGE is `ravel'.")

  (defun org-ravel-reset-confirm (value)
    "Revert `org-confirm-babel-evaluate' as buffer local VALUE."
    (when org-confirm-babel-evaluate 
      (setf org-confirm-babel-evaluate 
            value)))
    
#+END_SRC
*** TODO defun-org-babel-execute:ravel
:TODO:
engine needs to go somewhere. 

- Maybe best to pass it on to the chunk styling functions. That way,
  brew chunks can ignore the engine spec in sorting out how to handle
  the ravel spec.

- or cons it to ravel-attr, which brew can ignore

:END:



`org-babel-execute:ravel' calls formatting functions for the code. No
actual code is run. Also need to add some kind of alias for edit modes
if Rcpp is to be supported. Like `(defalias 'Rcpp-mode 'c++-mode)'

#+NAME: defun-org-babel-execute:ravel
#+BEGIN_SRC emacs-lisp
  (defun org-babel-execute:ravel (body params)
    "Format BODY as ravel."
     (save-excursion
       (if (string= "none" (cdr (assoc :exports params)))
           ""
         (let*
             ((oec (org-element-context))
              (ravel-attr (org-element-property :attr_ravel oec))
              (type (org-element-type oec))
              (headers params)
              (ravelarg (cdr (assoc :ravel headers)))
              (engine (cdr (assoc :engine headers)))
              (ravelstyle (cdr (assoc :ravel-style headers)))
              (label (org-element-property :name oec))
              (non-ravelargs (assq-delete-all :ravel headers))
              (chunk-style  
               (org-ravel-get-style ravelstyle))
              (full-body
               (org-babel-expand-body:ravel body params)))
           (unless (string= "R" engine)
             (setq ravel-attr 
                   (cons (format "engine=%S" engine)
                         ravel-attr)))
           (if (equal type 'inline-src-block)
               (org-ravel-snippetize chunk-style ravelarg non-ravelargs full-body)
             (org-ravel-blockify chunk-style label ravelarg ravel-attr 
                                 non-ravelargs full-body))))))
#+END_SRC
*** defun-org-ravel-snippetize/blockify

   Call the chunk-style functions to format the code.

#+NAME: defun-org-ravel-snippetize
#+BEGIN_SRC emacs-lisp
  (defun org-ravel-snippetize (chunk-style ravelarg r-headers-attr body)
    "Using CHUNK-STYLE and RAVELARG format BODY, then wrap it
  inside an export snippet."
    (format "@@ravel:%s@@"
            (funcall (nth 1 chunk-style) 
                     ravelarg r-headers-attr body)))

  (defun  org-ravel-blockify 
    (chunk-style label ravelarg ravel-attr non-ravelargs body)
     "Using CHUNK-STYLE, RAVEL-ATTR and RAVELARG format BODY and wrap it
  inside an export block."
             (funcall (nth 0 chunk-style) label ravelarg 
                      ravel-attr non-ravelargs body))
#+END_SRC
*** defun-org-ravel-get-style
#+NAME: defun-org-ravel-get-style
#+BEGIN_SRC emacs-lisp
  (defun org-ravel-get-style (style-from-header)
    "Return the chunk style for STYLE-FROM-HEADER or find it in
  properties or use `org-ravel-style' by default."
    (or 
     (assoc-default 
      (or style-from-header 
          (cdr (assoc 
                :ravel-style 
                (org-babel-parse-header-arguments 
                 (org-entry-get (point) 
                                "header-args:ravel" 
                                'inherit))))
          org-ravel-style) 
      org-ravel-style-alist 'string=)
      (user-error "Ravel-style: %S not found. Consult `org-ravel-style-alist'" 
                  style-from-header)))
   
#+END_SRC

* Chunk styling

These functions will be called by the transcoders or used to set up
functions to be so called.

** defun-org-ravel-attr-plus-header
#+NAME: defun-org-ravel-attr-plus-header
#+BEGIN_SRC emacs-lisp
  (defun org-ravel-attr-plus-header 
    (label ravelarg ravel-attr)
    "Format RAVEL-ATTR and add RAVELARG." 
    (mapconcat #'identity 
               (delete nil 
                       (cons label 
                             (cons ravelarg ravel-attr))) ", "))

#+END_SRC


** defmacro-org-ravel-deefun

`intern' is needed here to be sure that `name' ends up on `obarray'

#+NAME: defmacro-org-ravel-deefun
#+BEGIN_SRC emacs-lisp
   (defmacro org-ravel-deefun (name arglist body)
     "A simple `defun' with NAME as a string and formatted BODY as the
  docstring. See `org-ravel-style-x'."
     (let ((name (intern name))) 
       (list 'defalias
             (list 'quote name)
             (list 'function
                   (cons 'lambda
                         (list arglist body)))
             (concat "Run this:\n\n"
                     (pp-to-string body)))))

#+END_SRC

** defmacro-org-ravel-style-x
#+NAME: defmacro-org-ravel-style-x
#+BEGIN_SRC emacs-lisp
   (defmacro org-ravel-style-x (x xblock xinline &optional xcode)
     "Make style functions.

  The functions are `org-ravel-block-X' and `org-ravel-inline-X'
  where X names the style, XBLOCK gives the block format, XINLINE gives the 
  inline format, and XCODE is an optional line prefix.

   `org-ravel-block-X' defines the Chunk code style.  It's arguments are  
       LABEL - the chunk name, 
       RAVEL - header args as a string, 
       ATTR-RAVEL - attributes to be combined with RAVEL,
       R-HEADERS-ATTR - other headers from Babel as a string parseable 
        by `org-babel-parse-header-arguments', 
       SRC-CODE is the code from the block.

   `org-ravel-inline-X' defines the inline code style.  It's arguments
       are RAVEL, R-HEADERS-ATTR, SRC-CODE as above.  Note that only SRC-CODE is 
       used in this macro, but other arguments may be used in hand tooled inline
       style functions."
      (let ((blk-args
             '(label ravel attr-ravel r-headers-attr src-code))
            (inline-args '(ravel r-headers-attr src-code))
            (blk-body
             `(let ((ravel  (org-ravel-attr-plus-header label ravel attr-ravel)))
                ,(if xcode 
                     `(format ,xblock ravel 
                              (replace-regexp-in-string "^" ,xcode src-code))
                   `(format ,xblock ravel src-code))))
           (inline-body `(format ,xinline src-code))
           (bname (concat "org-ravel-block-" x))
           (iname (concat "org-ravel-inline-" x)))
       (eval (list 'org-ravel-deefun bname blk-args blk-body))
       (eval (list 'org-ravel-deefun iname inline-args inline-body))
       (format "Functions: %s and %s" bname iname)))

#+END_SRC
** brew-style

Brew needs to wrap the code inside "<% ... %>" and possibly add
additional markup. So the `org-ravel-style-x' macro is not used to
produce the `org-ravel-block/inline-brew' functions.

*** defun-org-ravel-format-brew-spec
#+NAME: defun-org-ravel-format-brew-spec
#+BEGIN_SRC emacs-lisp
  (defun org-ravel-format-brew-spec (&optional spec)
    "Check a brew SPEC, escape % signs, and add a %s spec."
    (let
        ((spec (or spec "<% %>")))
      (if (string-match 
           "<\\(%+\\)\\([=]?\\)\\(.+?\\)\\([{}]?[ ]*-?\\)\\(%+\\)>" 
           spec)
          (let (
                (opct (match-string 1 spec))
                (eqsign (match-string 2 spec))
                (filler (match-string 3 spec))
                (enddash (match-string 4 spec))
                (clpct (match-string 5 spec)))
            (if (string= opct clpct)
                (concat "<" opct opct eqsign " %s " enddash clpct clpct ">")
              (error "Percent signs do not balance:%s" spec)))
        (error "Invalid spec:%s" spec))))

#+END_SRC

*** defun-org-ravel-block-brew
#+NAME: defun-org-ravel-block-brew
#+BEGIN_SRC emacs-lisp
  (defun org-ravel-block-brew (label ravel attr_ravel r-headers-attr src-code)
    "Chunk style for rnw style.  LABEL is the chunk name, RAVEL is
  the collection of ravel args as a string, ATTR_RAVEL and
  R-HEADERS-ATTR are ignored here, SRC-CODE is the code from the
  block."
    (format (org-ravel-format-brew-spec ravel) src-code))

  (defun org-ravel-inline-brew (ravel r-headers-attr src-code)
    "Inline-src style for rnw style. 
  RAVEL is the collection of ravel args as a string, R-HEADERS-ATTR
  is the collection of headers from Babel as a string parseable by
  `org-babel-parse-header-arguments', SRC-CODE is the code from the
  block."
    (format (org-ravel-format-brew-spec
             (or ravel "<%= code -%>"))
            src-code))

#+END_SRC
** standard block/inline chunk styles

See the `org-ravel-style-x' docstring for more details.

*** org-ravel-style-x-rnw
#+NAME: org-ravel-style-x-rnw
#+BEGIN_SRC emacs-lisp
  (org-ravel-style-x "rnw"   
  "<<%s>>=\n%s\n@ %%def" 
  "\\Sexpr{ %s }")
#+END_SRC
*** org-ravel-style-x-tex
#+NAME: org-ravel-style-x-tex
#+BEGIN_SRC emacs-lisp
  (org-ravel-style-x "tex"   
                     "%% begin.rcode( %s )\n%s\n%% end.code" 
                     "\\rinline{ %s }"
                     "%")
#+END_SRC
*** org-ravel-style-x-html
#+NAME: org-ravel-style-x-html
#+BEGIN_SRC emacs-lisp
  (org-ravel-style-x "html"   
  "<!--begin.rcode  %s \n%s\nend.rcode-->" 
  "<!--rinline  %s  -->")
#+END_SRC
*** org-ravel-style-x-md
#+NAME: org-ravel-style-x-md
#+BEGIN_SRC emacs-lisp
  (org-ravel-style-x "md"   
  "```{r  %s }\n%s \n```" 
  "`r  %s `")


#+END_SRC
*** org-ravel-style-x-braces
#+NAME: org-ravel-style-x-braces
#+BEGIN_SRC emacs-lisp
  (org-ravel-style-x "braces"   
  "{{%0.0s%s}}" 
  "{{%s}}")

#+END_SRC
* Exporter
** Transcoders

Transcoders for `export-block' and `export-snippet' are defined for
the ravel family of backends. For `ravel' blocks/snippets, they merely
return their content. For other blocks/snippets, they fall back to the
transcoders for the parent backend.

*** TODO defun-org-ravel-export-block now special-block is REVERTED
:TODO:

- ANN :: http://lists.gnu.org/archive/html/emacs-orgmode/2014-08/msg01007.html

- reverted :: export-blocks are deprecated --- use special blocks
              instead. `org-ravel-special-block' implements this.

Note that I do not query org-export-raw-special-block-p, because this
is implied for ravel - it might be necessary to leave the old export
block transcoder in place for back compatibility


Porbably this does not matter - why would an on-the-fly backend be used
without having any ravele backends registered:  on the fly backends
need to have RAVEL entry in `org-element-block-name-alist' iff there
are not ravel backends registered - or the special block transcoder
needs to handle them

But now I have doctored org-ravel-special-block to allow for this
possibility.

I have just [2014-09-15 Mon] added a :blocks entry to
org-ravel-create-backend, but it does not alter the alist...
and maybe should not.

:END:

#+NAME: defun-org-ravel-special-block
#+BEGIN_SRC emacs-lisp 
  (defun org-ravel-special-block (special-block contents info)
     "Transcode a SPECIAL-BLOCK element from Org to ravel.
     CONTENTS is nil.  INFO is a plist holding contextual information."
     (if (equal (org-element-property :type special-block) "RAVEL")
         contents
       (let ((parent-backend (org-export-backend-parent backend)))
         (if parent-backend
             (org-export-with-backend 
              parent-backend special-block contents info)))))

#+END_SRC


#+NAME: defun-org-ravel-export-block
#+BEGIN_SRC emacs-lisp
  (defun org-ravel-export-block (export-block contents info)
    "Transcode a EXPORT-BLOCK element from Org to ravel.
    CONTENTS is nil.  INFO is a plist holding contextual information."
    (if (equal (org-element-property :type export-block) "RAVEL")
        (org-remove-indentation (org-element-property :value export-block))
      (let ((parent-backend (org-export-backend-parent backend)))
        (if parent-backend
            (org-export-with-backend 
             parent-backend export-block contents info)))))



#+END_SRC
*** defun-org-ravel-export-snippet
#+NAME: defun-org-ravel-export-snippet
#+BEGIN_SRC emacs-lisp
  (defun org-ravel-export-snippet (export-snippet contents info)
    "Transcode a EXPORT-SNIPPET element from Org to ravel.
    CONTENTS is nil.  INFO is a plist holding contextual information."
    (if (eq (org-export-snippet-backend export-snippet) 'ravel)
        (org-remove-indentation (org-element-property :value export-snippet))
       (let ((parent-backend (org-export-backend-parent backend)))
         (if parent-backend
             (org-export-with-backend 
              parent-backend export-snippet contents info)))))

#+END_SRC
** export to file, to buffer, string as string


*** defun-org-ravel-create-backend
#+BEGIN_SRC emacs-lisp
  (defun  org-ravel-create-backend (parent &optional style)
    "Create a ravel-compliant backend from PARENT using STYLE.
    Hence, (org-ravel-create-backend 'ascii \"md\") creates a backend
    whose parent is ascii and default style is \"md\"."
    (org-export-create-backend
     :parent parent
     :transcoders '((export-snippet . org-ravel-export-snippet)
                    (export-block . org-ravel-export-block)
                    (special-block . org-ravel-special-block))
     :options (cons `(:ravel-style "RAVEL_STYLE" nil
                                   ,style t)
                    (org-export-backend-options 
                     (or (org-export-get-backend parent)
                         (user-error 
                          (format "Backend %S is not loaded" parent )))))
     :blocks    (let ((eblocks 
                       (org-export-backend-blocks 
                        (org-export-get-backend parent))))
                  (add-to-list 'eblocks "RAVEL"))))

#+END_SRC
*** defun-org-ravel-export-string-as
#+NAME: defun-org-ravel-export-string-as
#+BEGIN_SRC emacs-lisp
  (defun org-ravel-export-string-as 
    (string backend &optional body-only ext-plist engines style)
    "Export STRING using  BACKEND with BODY-ONLY and  EXT-PLIST,
  all as per `org-export-string-as'.  If non-nil, ENGINES will set
  `org-ravel-run' locally. Otherwise, an attempt will be made to
  replace them with `org-ravel-run' or `org-ravel-engines'.  STYLE
  will set `org-ravel-style' if non-nil, otherwise
  `org-ravel-style' or the default for BACKEND will be used.  Often
  this is run by Babel using a backend that is not ravel-compliant
  to produce a string that is used in a Babel src block."
    (let* ((org-ravel-run
           (or engines org-ravel-run org-ravel-engines))
           (backend (if (symbolp backend)
                                (org-export-get-backend backend)
                              backend))
           (org-ravel-style
            (or style org-ravel-style 
                (nth 3 
                     (assoc :ravel-style 
                            (org-export-backend-options
                             backend)))))
           (org-confirm-babel-evaluate t))
      (org-ravel-reset-confirm 
       org-ravel-no-confirm-for-ravel)
      (org-export-string-as string backend body-only ext-plist)))

#+END_SRC
*** defun-org-ravel-export-to-file

#+NAME: defun-org-ravel-export-to-file
#+BEGIN_SRC emacs-lisp
  (defun org-ravel-export-to-file
    (backend file &optional async subtreep visible-only
             body-only ext-plist post-process engines style)
    "Export invoking ravel to FILE using BACKEND. ASYNC must be
    nil, but SUBTREEP, VISIBLE-ONLY, BODY-ONLY, EXT-PLIST, and
    POST-PROCESS are passed to `org-export-to-file'.  ENGINES
    supplies a value for `org-ravel-run' and STYLE for
    `org-ravel-style'. If a backend is used that is not set up for
    ravel, it usually best to use, e.g.

       `(org-ravel-export-to-file
         (org-ravel-create-backend 'ascii \"md\") ... )'

    to create a ravel-compliant backend." 
    (let* ((org-ravel-run
            (or engines org-ravel-run org-ravel-engines))
           (backend (if (symbolp backend)
                        (org-export-get-backend backend)
                      backend))
           (org-ravel-style
              (or style org-ravel-style 
                  (nth 3 
                       (assoc :ravel-style 
                              (org-export-backend-options
                               backend)))))
           (org-confirm-babel-evaluate t))
      (when async (user-error "ASYNC not allow for ravel"))
      (org-ravel-reset-confirm 
       org-ravel-no-confirm-for-ravel)
      (org-export-to-file backend file async subtreep visible-only
                          body-only ext-plist post-process)
      ))

#+END_SRC
*** defun-org-ravel-export-to-buffer

#+NAME: defun-org-ravel-export-to-buffer
#+BEGIN_SRC emacs-lisp
    (defun org-ravel-export-to-buffer
      (backend buffer &optional async subtreep visible-only
               body-only ext-plist post-process engines style)
    "Export invoking ravel to BUFFER using BACKEND. ASYNC must be
  nil, but SUBTREEP, VISIBLE-ONLY, BODY-ONLY, EXT-PLIST, and
  POST-PROCESS are passed to `org-export-to-buffer'.  ENGINES
  supplies a value for `org-ravel-run' and STYLE for
  `org-ravel-style'. If a backend is used that is not set up for
  ravel, it usually best to use, e.g.

     `(org-ravel-export-to-buffer
       (org-ravel-create-backend 'ascii \"md\") ... )'

  to create a ravel-compliant backend." 
    (let* ((org-ravel-run
             (or engines org-ravel-run org-ravel-engines))
            (backend (if (symbolp backend)
                            (org-export-get-backend backend)
                          backend))
               (org-ravel-style
                (or style org-ravel-style 
                    (nth 3 
                         (assoc :ravel-style 
                                (org-export-backend-options
                                 backend)))))
               (org-confirm-babel-evaluate t))
      (when async (user-error "ASYNC not allow for ravel"))
      (org-ravel-reset-confirm 
       org-ravel-no-confirm-for-ravel)
      (org-export-to-buffer backend buffer async subtreep visible-only
                          body-only ext-plist post-process)
      ))

#+END_SRC

** Backend Definitions


*** defun-org-ravel-extension
#+NAME: defun-org-ravel-extension
#+BEGIN_SRC emacs-lisp
  (defun org-ravel-extension (style)
    "Get the file extension for STYLE."
    (nth 3 (assoc-string style org-ravel-style-alist)))


#+END_SRC
*** TODO defmacro-org-ravel-to-file
:TODOWHAT:

Looks like unwind-protect is overkill - interrupts to (let ...) seem
to revert the variables to their former values.

There may be some other simplifications now that org-ravel-export* and
org-ravel-create-backend funs exist.

defun-org-ravel-export-to-file-or-buffer needs to specify the right
form - probably a lambda form - when buf-fun is t

Maybe this

#+BEGIN_SRC emacs-lisp :tangle no
out-file-or-buf (concat 
                   "* " (symbol-name
                         (if (symbolp ravel-bkend) ravel-bkend
                           (eval ravel-bkend)))" Output *")

#+END_SRC

would do...

Probably need to pretty up the unit tests.

:END:


#+NAME: defmacro-ravel-define-exporter
#+BEGIN_SRC emacs-lisp
  (defmacro org-ravel-define-exporter 
    (ravel-backend parent menu-key menu-label style-default
                   &optional fileout bufferout post-proc)
    "Function to define ravel backends with these args:  

         RAVEL-BACKEND is a symbol naming the backend derived from 

         PARENT - a registered backend,
   
         MENU-LABEL tells how to label the backend in the 
         dispatch menu,

         MENU-KEY should be an integer code for a lower-case
         character like `?a' to refer to file dispatch,

         STYLE-DEFAULT is the style to use if not specified as a
          `:ravel-style' attribute,

         FILEOUT can be a lambda form with args like
         `org-export-to-file' or `nil' or `t; (which use
         `org-export-to-file' with generic args),

         BUFFEROUT can be a lambda form with args like
         `org-export-to-buffer' or `t' (which uses
         `org-export-to-buffer'with generic args) (`(upcase
         MENU-KEY)' will be used for menu dispatch) or `nil' for no
         buffer dispatcher, and

         POST-PROC for a post-export hook function

    Note that `org-babel-confirm-evaluate' is set locally (in the
    process buffers only) to `org-ravel-no-confirm-for-ravel', which
    hold a `lambda' function.  To override this, create a variable
    with that name. "
    `(org-export-define-derived-backend 
         ,ravel-backend 
         ,parent
       :translate-alist '(
                          (export-snippet . org-ravel-export-snippet)
                          (export-block . org-ravel-export-block)
                          (special-block . org-ravel-special-block))
       :options-alist (cons 
                       '(:ravel-style "RAVEL_STYLE" 
                                      nil ,style-default t)
                       (org-export-backend-options 
                        (or (org-export-get-backend ,parent)
                            (user-error 
                             (format "Backend %S is not loaded" ,parent )))))
       :export-block    (cons "RAVEL" 
                              (org-export-backend-blocks 
                               (org-export-get-backend ,parent)))
       
       :menu-entry
       '(?r "Ravel"
            ,(remq nil
                   `((,menu-key ,(concat menu-label " file")
                                ,(org-ravel-export-to-file-or-buffer 
                                  ravel-backend style-default fileout))
                     ,(if bufferout
                          `(,(upcase menu-key) ,(concat menu-label " buffer")
                            ,(org-ravel-export-to-file-or-buffer 
                              ravel-backend style-default nil bufferout 
                              post-proc))))))))
#+END_SRC


#+NAME: defun-org-ravel-export-to-file-or-buffer 
#+BEGIN_SRC emacs-lisp 
  (defun  org-ravel-export-to-file-or-buffer 
    (ravel-bkend style-def &optional file-fun buf-fun post-proc)
  "Construct an action - in the sense of `org-export-define-backend' (see 
  its docstring) - for RAVEL-BKEND. `org-ravel-define-exporter' calls this function
  and its docstring describes the other arguments STYLE-DEF(AULT), FILE-FUN, 
  BUF-FUN and POST-PROC. RAVEL-BKEND must be a quoted symbol when evaluated,
  which is automatic when used by `org-ravel-define-exporter'."
    (let (c-lambda  out-file-or-buf) 
      (if buf-fun
          ;; configure buffer output
          (setq 
           c-lambda (lambda 
                      (&optional async subtreep visible-only 
                                 body-only ext-plist post-process))
           out-file-or-buf (concat 
                            "* " (symbol-name (eval ravel-bkend)) " Output *")
           buf-fun  (if (eq buf-fun t) 
                        (lambda (back buf 
                                      &optional async subt vis bod ext-p post-pr)
                          (org-export-to-buffer back buf async subt 
                                                vis bod ext-p post-pr))
                      buf-fun))
        
        ;; configure file output
        (setq 
         c-lambda (lambda 
                    (&optional async subtreep visible-only 
                               body-only ext-plist))
         out-file-or-buf '(org-export-output-file-name 
                           (org-ravel-extension 
                            org-ravel-style) subtreep)
         file-fun (or
                   (unless (eq t file-fun) file-fun)
                   (setq file-fun 
                         (lambda (back buf 
                                       &optional async subt vis bod ext-p post-pr)
                           (org-export-to-file back buf async subt 
                                               vis bod ext-p post-pr)))))) 
      `(,@c-lambda
        ,@`(
            (interactive)
            (let* ((org-ravel-run org-ravel-engines)
                   (org-ravel-style 
                    (or 
                     (org-entry-get (point-min) "ravel-style" t)
                     ,style-def))
                   ;; honor local non-nil org-confirm-babel-evaluate
                   (org-confirm-babel-evaluate-old 
                    org-confirm-babel-evaluate)
                   (outfile ,out-file-or-buf))
              ;;
              (unwind-protect
                  (progn
                    (org-ravel-reset-confirm 
                     org-ravel-no-confirm-for-ravel)
                    (when async (user-error "ASYNC is not valid for ravel. "))
                    ,(if buf-fun
                         `(funcall ,buf-fun ,ravel-bkend outfile
                                   nil subtreep visible-only body-only 
                                   ext-plist ,post-proc)
                       `(funcall ,file-fun ,ravel-bkend outfile
                                 nil subtreep visible-only body-only 
                                 ext-plist)))
                (org-ravel-reset-confirm 
                 org-confirm-babel-evaluate-old )))))))

#+END_SRC


** run-org-ravel-to-file: Create Backends
:TODOWHAT:
Maybe make just latex, ascii, md and html as defaults. Make templates
for other backends and maybe a way to easily add them.

For a slicker approach see org-export-backends' docstring

:END:


#+NAME: run-org-ravel-to-file
#+BEGIN_SRC emacs-lisp 
  (let ((backends (mapcar 'org-export-backend-name org-export--registered-backends)))
  (unless (memq 'latex backends) 
    (load "ox-latex"))
  (org-ravel-define-exporter
   'ravel-latex 
   'latex ?l "Ravel-LaTeX" "rnw" nil t (lambda () (LaTeX-mode)))
  (unless (memq 'beamer backends) 
    (load "ox-beamer"))
  (org-ravel-define-exporter
   'ravel-beamer 
   'beamer ?b "Ravel-beamer" "rnw" nil t (lambda () (LaTeX-mode)))
  (unless (memq 'html backends) 
    (load "ox-html"))
  (org-ravel-define-exporter
   'ravel-html 
   'html ?h "Ravel-html" "html" nil t )
  (unless (memq 'md backends) 
    (load "ox-md"))
  (org-ravel-define-exporter
   'ravel-markdown 
   'md ?m "Ravel-markdown" "md" nil t ))
#+END_SRC

* provide ravel							   :noexport:
:DEVNOTES:
#+BEGIN_SRC emacs-lisp :tangle ox-ravel.el
  (provide 'ox-ravel)
  
  ;;; ox-ravel.el ends here
#+END_SRC
:END:

